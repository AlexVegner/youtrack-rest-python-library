#! /usr/bin/env python

import sys
import os
import time
import readline
import rlcompleter
from cmd import Cmd
from youtrack.connection import Connection;
import clint.textui
from clint.textui import colored
from clint.textui.cols import console_width
import tempfile

if sys.platform == 'darwin':
    readline.parse_and_bind('bind ^I rl_complete')
else:
    readline.parse_and_bind('tab: complete')

def unistr(s):
    if isinstance(s, unicode):
        s = s.encode('utf-8')
    return s

def puts(s, *args, **kwargs):
    return clint.textui.puts(unistr(s), *args, **kwargs)

def ftime(timestamp):
    return time.strftime('%d %b %Y %T', time.localtime(int(timestamp) / 1000))


editor = os.environ.get('EDITOR', 'vi')

issue_draft_template = '''
# Please, enter issue details above.
# Lines starting with '#' will be ignored.
#
# Example:
#   First line contains issue summary
#   Description begins on second line and continues until empty line is found.
#   All following lines (after empty line) are used to set issue fields.
#
#   type: task
#   priority: critical
#   state: open
#   assignee: john.smith
'''

COMMENT_DRAFT_TEMPLATE = '''
'''


class YouTrackCmd(Cmd):
    def __init__(self, url, login, password):
        Cmd.__init__(self)
        self.prompt = 'youtrack> '
        self.last_shown_issue = None
        self.yt = Connection(url, login, password)

    def emptyline(self):
        pass

    def onecmd(self, line):
        try:
            return Cmd.onecmd(self, line)
        except Exception, e:
            print e

    def precmd(self, cmdline):
        if cmdline == 'EOF':
            cmdline = 'exit EOF'
        return cmdline

    def do_exit(self, arg):
        if arg == 'EOF':
            print ''
        return True

    def help_find(self):
        print 'find [query]'

    def do_find(self, arg):
        import pydoc
        il = u''
        after = 0
        chunk = 10
        limit = 150
        while True:
            issues = self.yt.getIssues(None, arg, after, chunk)
            for issue in issues:
                il += u'#' + colored.green(issue.id.upper()) + u'  ' + issue.summary + u'\n'
                after += 1
                if after == limit:
                    break
            if len(issues) < chunk:
                break
            if after == limit:
                break
        else:
            il = 'No issues found'
        puts(il)
        self.last_shown_issue = None

    def complete_find(self, text, line, begidx, endidx):
        suggestions = []
        relevant = []
        line = line[4:].rstrip()
        for s in self.yt.getSearchIntelliSense(line, begidx).suggestions:
            match = line[s['completion']['start']:s['completion']['end']].lower()
            option = s['option']
            if not (s['match']['start'] == 0 and option.lower().startswith(match)):
                continue
            if 'prefix' in s:
                option = s['prefix'] + option
            if 'suffix' in s:
                option += s['suffix']
            suggestions.append(option)
        return suggestions

    def help_show(self):
        print 'show issue_id1 [issue_id2...]'

    def do_show(self, issue_ids):
        issues = [self.yt.getIssue(_id) for _id in issue_ids.split()]
        for issue in issues:
            puts(u'#' + colored.green(issue.id.upper()) + u'  ' + issue.summary + u'\n')
            puts('Created by %s, %s' % (issue.reporterFullName, ftime(issue.created)))
            if issue.updated:
                puts('Updated by %s, %s' % (issue.updaterFullName, ftime(issue.updated)))
            if hasattr(issue, 'description'):
                puts(u'\n' + colored.blue('[Description]'))
                puts(issue.description.strip())
            cf = []
            for attr in issue:
                if attr in ('id', 'summary', 'description', 'numberInProject', 'commentsCount',
                            'votes', 'created', 'updated', 'reporterFullName', 'updaterFullName',
                            'reporterName', 'updaterName', 'resolved', 'projectShortName'):
                    continue
                value = issue[attr]
                if isinstance(value, list):
                    value = ', '.join(value)
                cf.append((attr + u': ' +  value).encode('utf-8'))
            puts(u'\n' + colored.blue('[Custom Fields]'))
            self.columnize(cf, console_width())
            puts('')
            self.last_shown_issue = issue.id

    def help_comments(self):
        print 'comments issue_id1 [issue_id2 ...]'

    def do_comments(self, issue_ids):
        if not issue_ids:
            issue_ids = self.last_shown_issue or ''
        ids = [_id for _id in issue_ids.split()]
        for _id in ids:
            try:
                comments = self.yt.getComments(_id)
            except Exception:
                pass
            if comments:
                puts('#' + colored.green(_id.upper()) + '\n')
                for c in [c for c in comments if c.deleted.lower() != 'true']:
                    puts('%s, %s' % (unistr(c.authorFullName), ftime(c.created)))
                    puts(c.text.strip())
                    puts('')

    def help_addissue(self):
        print 'addissue project_id'

    def parse_draft_content(self, content):
        summary = u''
        description = u''
        fields = {}
        mode = 0
        for line in content:
            if mode == 0:
                summary = line.strip()
                if summary:
                    mode = 1
            elif mode == 1:
                if line.strip():
                    description += line
                else:
                    mode = 2
            elif mode == 2:
                fld = []
                for s in line.split(':', 1):
                    s = s.strip()
                    if s:
                        fld.append(s)
                if len(fld) == 2:
                    fields[fld[0].lower()] = fld[1]
        return (summary, description, fields)

    def do_addissue(self, project_id):
        if project_id is None or not len(project_id):
            print 'You have to set ProjectId'
            return
        tmp = tempfile.NamedTemporaryFile(delete=False)
        tmp.write(issue_draft_template)
        tmp.close()
        os.system(editor + ' ' + tmp.name)
        with open(tmp.name, 'r') as content_file:
            content = [line for line in content_file.readlines() if not line.lstrip().startswith('#')]
        summary, description, fields = self.parse_draft_content(content)
        if summary:
            self.yt.create_issue(project_id, summary, description, fields)
        os.unlink(tmp.name)

    def help_addcomment(self):
        print 'addcomment issue_id'

    def do_addcomment(self, issue_id):
        tmp = tempfile.NamedTemporaryFile(delete=False)
        tmp.write("\n\n")
        tmp.write("# Please enter comment for issue " + issue_id + "\n")
        tmp.write("# Lines starting with '#' will be ignored\n")
        tmp.close()
        os.system(editor + ' ' + tmp.name)
        with open(tmp.name, 'r') as content_file:
            content = [line for line in content_file.readlines() if not line.lstrip().startswith('#')]
        if content:
            self.yt.executeCommand(issue_id, '', ''.join(content))
        os.unlink(tmp.name)



if __name__ == '__main__':
    cmd = YouTrackCmd(sys.argv[1], sys.argv[2], sys.argv[3])
    cmd.cmdloop('YouTrack command line interface 0.1')
